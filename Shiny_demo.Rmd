---
title: 
output:
  html_document: default
  html_notebook: default
---

```{r, message=FALSE, warning = FALSE}
library(shiny)
library(dplyr)
library(historydata)
library(ggplot2)
data("paulist_missions")

```

# Shiny

Shiny is an R program for making web applications. The apps allow users to manipulate variables on a website and explore a particular set of data without having to know computer code. This makes Shiny a valuable tool for those interested in public history or wishing to make their data accessible by a larger audience. Interesting examples of Shiny apps can be found in the Shinny [showcase](https://www.rstudio.com/products/shiny/shiny-user-showcase/).   

## How Shiny Works

Shiny is an example of reactive programming. In essence this means that the app will react or respond to changes made by the end user. A visitor to a website can change any number of variables or inputs and instantly see changes in the displayed output. In order to understand how this works, it is necessary to understand the structure of and logic behind a Shiny app.



### The Structure and Logic of Shiny

Shiny apps use the following 3 part architecture: 

```{r, eval=FALSE}
ui <- fluidPage("Hello World")

server <- function(input, output) {}

shinyApp(ui = ui, server = server)
```

1. There is a user interface or webpage that displays the app and allows users to interact with it.

2. There is a set of instructions for the server that is running R and generating the different outputs based on the input changes made in the user interface (today we will run our apps locally on our laptops). 

3. Finally, there is the shinyApp that that connects the server to the ui. 

It is important to note that the output displayed on a webpage is still being generated by an R session running on a server. When a visitor to the webpage changes an input, that change also occurs in the R session which reruns the code and sends the new output to the website to be displayed. If you run the code above, a page displaying "Hello World" will be generated because we did not provide any other content. Notice that R on your laptop (or GMU's server) is maintaining this page (it is waiting for someone to interact with it). If you try to run other code without stopping this process, your ations will be put on hold. You must first end the process. 

It is helpful to think about Shiny apps in terms of inputs and outputs. All of the code is structured so that simple changes to the input can quickly and effortlessly be transformed into different outputs. Lets create a simple Shiny app to demonstrate how this works.

## A Simple Shiny App

In order to create a meaningful visualization, we need data. This example will use the `pualist_missions` from the `historydata` package. Once we have our data, we will start modifying our basic Shiny app architecture. Shiny comes with a number of different ui input, output, and rendering functions. In the example below, I used the `radioButtons` to provide the user with an option to select specific categories. The `inputId` is just a name that you provide. The second argument is a label. The third argument is a list of choices. The `plotOutput` is another arbitrary name that you give to the eventual plot. Because the ui is essentially an html webpage, the `plotOutput` function is simply placing the plot on the page without any instructions. Thus when this app is displayed on a web page it will follow a simple structure of placing the buttons first and then the plot. 

Notice how the syntax of the names change between the ui and the server. The `inputId` from the ui becomes the second part of `input$category`. This is the structure that allows for reactivity. We are essentially assigning a placeholder into our code that represents the eventual input selected by the user. Therefore, the code is written in a way that any value can be assigned to the place holder and then rerun in order to produce new outputs.

```{r, eval=FALSE}
ui <- fluidPage(radioButtons(inputId = "category", "Select a Category",
                  c("Confessions" = "pconv", "Converts" = "pconf")),
    
  plotOutput("distPlot")
)

server <- function(input, output) {
  output$distPlot <- renderPlot({
      dist <-switch(input$category,
           pconf = paulist_missions$confessions,
           pconv = paulist_missions$converts)
      
    hist(dist, main = "Distribution of Converts/Confessions Per Mission", col = "green")
    })
}

shinyApp(ui = ui, server = server)
```

Now we will take a look at a different function `sliderInput`. You will notice that the arguments are similar to that of `radioButtons` but instead of choices, the third argument being a list of choices, we specify the min, max, and value to be displayed. Notice that this plot uses `ggplot`. Inside the server function, there are a set of {}. This is where the plot is created. Creating the plot works just like any other plot except that we use the `input$` to indicate that placeholder value. In the example below, the `inputID` of `mission_year` from the ui is used to filter the data by year, `filter(year == input$mission_year)`. 


```{r, eval=FALSE}

ui <-  fluidPage(sliderInput(inputId = "mission_year",
                  "Year",
                  min = min(paulist_missions$year),
                  max = max(paulist_missions$year),
                  value = min(paulist_missions$year),
                  animate = animationOptions(interval = 1000),
                  sep = ""),

plotOutput("mission_plot")
)



server <- function(input, output) {
  filtered_missions <- reactive({
    paulist_missions %>%
      filter(year == input$mission_year)
  })

   output$mission_plot<- renderPlot({
    df <- filtered_missions()
    ggplot(df, aes(x = confessions, y = converts)) +
    geom_point() +
    labs(title = paste0("Missions for ", input$mission_year)) +
    theme(plot.title = element_text(hjust = 0.5))
  })
  
  
}

shinyApp(ui = ui, server = server)
  
```

Shiny apps are not limited to a single input or even a single output. Below is an example of an app that uses both a `sliderInput` and a `textInput`. This allows users to filter by year and by state. 

```{r, eval=FALSE}

ui <-  fluidPage(sliderInput(inputId = "mission_year",
                  "Year",
                  min = min(paulist_missions$year),
                  max = max(paulist_missions$year),
                  value = 1851,
                  animate = animationOptions(interval = 1000),
                  sep = ""),

                 textInput(inputId = "mis_state", "Select state (example: NY) ", "NY"),
                          

plotOutput("mission_plot")
)



server <- function(input, output) {
  filtered_missions <- reactive({
    paulist_missions %>%
      filter(year == input$mission_year, state == input$mis_state)
  })

   output$mission_plot<- renderPlot({
    df <- filtered_missions()
    ggplot(df, aes(x = confessions, y = converts)) +
    geom_point(size = 4, col = "blue") +
    labs(title = paste0("Missions for ", input$mission_year)) +
    theme(plot.title = element_text(hjust = 0.5))
  })
  
  
}

shinyApp(ui = ui, server = server)
  
```
If you are interested in building Shiny apps, R studio provides numerous resources to help you get started on their [website](https://shiny.rstudio.com/). The video tutorial is very helpful and covers the basics of creating a simple Shinny app. This tutorial also covers how to put your Shiny app online for others to see. 